
filter {
	if [Product] == "tosca" {

		# Get rid of the header message in xml
		if [message] =~ /xml version=/ { drop { } }
			
		xml {
			source => "message"
			store_xml => true
			target => "_xml"
			force_array => false
			# max_lines => 5000
		}

		mutate {
			add_field => { "[@metadata][index_prefix]" => "%{Product}-%{CustCode}" }	
			lowercase => [ "[@metadata][index_prefix]" ]
			add_field => { "[index_prefix]" => "%{[@metadata][index_prefix]}" }
		}

		ruby {
			code => '
				x = event.get("[@metadata][index_prefix]").downcase
				event.set("[@metadata][index_prefix]",x)

				y = event.get("_xml")

				if !y.nil?
					y.each {|k, v|
						v.gsub!(/^true$/i,"true") if !v.nil?
						v.gsub!(/^false$/i,"false") if !v.nil?
						event.set(k,v)
					}
				end

				event.remove("_xml")
				event.remove("message")
			'
		}

		date {
			match => ["[ModifiedAt]","MM/dd/yyyy H:mm:ss a","M/dd/yyyy H:mm:ss a"]
			timezone => "Australia/Sydney"
			target => "@timestamp"
			remove_field => [ "ModifiedAt" ]
		}

		date {
			match => ["[ModifiedAtDate]","MM/dd/yyyy H:mm:ss a","M/dd/yyyy H:mm:ss a"]
			timezone => "Australia/Sydney"
			target => "ModifiedAtDate"
		}

		date {
			match => ["[CreatedAt]","MM/dd/yyyy H:mm:ss a","M/dd/yyyy H:mm:ss a"]
			timezone => "Australia/Sydney"
			target => "CreatedAt"
		}

		date {
			match => ["[CreatedAtDate]","MM/dd/yyyy H:mm:ss a","M/dd/yyyy H:mm:ss a"]
			timezone => "Australia/Sydney"
			target => "CreatedAtDate"
		}

		mutate {
			convert => { "UpdateRevision" => "integer" }
			convert => { "Revision" => "integer" }

			convert => { "HasMissingReferences" => "boolean" }
			convert => { "IsTemplate" => "boolean" }
			convert => { "Disabled" => "boolean" }
			convert => { "IncludeForSynchronization" => "boolean" }
			convert => { "IsBusinessTestCase" => "boolean" }
			convert => { "ChangesAllowed" => "boolean" }
			convert => { "IsCheckedOutByMe" => "boolean" }
			
			# ExecutionList
			convert => { "NumberOfTestCases" => "integer" }
			convert => { "NumberOfTestCasesFailed" => "integer" }
			convert => { "NumberOfTestCasesPassed" => "integer" }
			convert => { "NumberOfTestCasesNotExecuted" => "integer" }
			convert => { "NumberOfTestCasesWithUnknownState" => "integer" }

			convert => { "IsViewingAllowed" => "boolean" }
			convert => { "IsOsvItem" => "boolean" }
			convert => { "HasNotUniqueNamedSubparts" => "boolean" }
			convert => { "OwningGroupInherited" => "boolean" }
			convert => { "IncludeInAnalytics" => "boolean" }
			convert => { "IsMandate" => "boolean" }
			convert => { "HasMandates" => "boolean" }
			convert => { "ContainsClassic" => "boolean" }
			convert => { "IsBusinessExecutionList" => "boolean" }
			convert => { "HasInconsistentParallelizationState" => "boolean" }
			convert => { "IncludeForAccumulation" => "boolean" }
			convert => { "IncludeForAccumulation" => "boolean" }

			convert => { "ManualItems" => "integer" }
			convert => { "AutomatedItems" => "integer" }

			#TestCaseLog
			convert => { "IsDeletedFromFileService" => "boolean" }
			convert => { "RetainOnFileService" => "boolean" }
			convert => { "Canceled" => "boolean" }
			convert => { "Recovered" => "boolean" }

			convert => { "Duration" => "float" }

			# TODO: Only remove original event if NOT failed processing
			remove_field => [ "[event][original]" ]
		}

		# Drop soem duplicates
		# if [ObjectType] == 'TestCase' and [UpdateRevision] == ''  { drop { } }

		kv {
			source => "TCProperties"
			target => "[Properties]"
			include_brackets => false
			field_split => ' '
			trim_key => " "
			remove_field => [ "TCProperties" ]
		}

		ruby {
			code => '
				t = Time.at(event.get("@timestamp").to_f)
				suffix = t.strftime("%Y%d%H%M%S")

				event.set("[@metadata][index_suffix]", suffix)
			'
		}

	}
}
